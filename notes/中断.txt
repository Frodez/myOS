BIOS位于实模式下，中断调用是在中断向量表中，通过软中断指令int ${中断号}调用。

中断向量表长1024字节，每个中断向量4字节，共计256个。初始化时内存地址位于0x0000（16位）。

DOS也位于实模式下，占据了0x20到0x27号中断向量。但DOS只使用了0x21中断号。调用DOS中断调用时，先向ah里写子功能号，然后调用int 0x21，于是就能调用不同的子功能了。

中断向量表只存在于实模式下。

Linux在进入保护模式后才建立中断例程。此时存在的是中断描述符表。Linux通过0x80指令加上eax寄存器来调用不同子功能。

最后，int指令在实模式下会调用中断向量表，而保护模式下会调用中断描述符表。

外部中断分为可屏蔽中断和不可屏蔽中断。

中断处理的过程往往会分为两部分：上半部分处理最紧急的中断应答，硬件复位等工作，需要关闭中断。下半部分则处理具体的逻辑，需要开启中断以实现嵌套中断。

不可屏蔽中断涉及到致命错误，无法被屏蔽。中断向量号为2。

内部中断分为软中断和异常。

软中断为软件主动发起的中断，不是客观错误，无法屏蔽。

int 8位立即数  为调用中断向量表中的中断
int3  为调试断点指令。触发的中断向量号为3。
用gdb或bochs调试程序时，实际上就是调试器fork了一个子进程，子进程用于运行被调试的程序。调试器中经常要设置断点，其原理就是父进程修改了子进程的指令，将其用int3指令替换，从而子进程调用了int3指令触发中断。
into  为中断溢出指令，触发的中断向量号为4。当eflags中OF位为1时有效，为0时无效。
bound  为检查数组越界指令，触发的中断向量号为5。
ud2  为未定义指令，触发的中断向量号为6。表示该指令CPU无法识别。

iret  中断返回指令。

异常则是CPU发生错误引起，无法屏蔽。

保护模式下，中断描述符表IDT中既存储了中断描述符，也有任务门描述符和陷阱门描述符。这些描述符被称为门。所有描述符长度为8字节。

保护模式中的中断门，任务门，陷阱门和调用门即指这里的门。另外任务门和调用门还可以存在于全局描述符表GDT和局部描述符表LDT中。

门中有对应的代码入口地址，类型，还有检查条件。

加载IDT对应的寄存器IDTR有专门的指令lidt 48位立即数。其中高16位为IDT界限，低32位为IDT基址。

根据中断指令中的中断向量号，找到IDT中对应的门描述符。
根据描述符中的代码段选择子和在代码段内的偏移量，还有门描述符的DPL。但是因为是中断调用，故没有请求者RPL。
然后判断当前特权级是否满足代码段DPL<CPL<=门描述符DPL。(如果是外部中断或者是异常，不需要检查门描述符DPL的约束)
之后才能执行中断调用程序。